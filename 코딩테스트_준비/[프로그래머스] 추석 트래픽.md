# [프로그래머스] 추석 트래픽

문제 링크: [https://programmers.co.kr/learn/courses/30/lessons/17676](https://programmers.co.kr/learn/courses/30/lessons/17676

##### 문제 설명

이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. **초당 최대 처리량**은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.

### 입력 형식

- `solution` 함수에 전달되는 `lines` 배열은 **N**(1 ≦ **N** ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 **S**와 처리시간 **T**가 공백으로 구분되어 있다.
- 응답완료시간 **S**는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 `2016-09-15 hh:mm:ss.sss` 형식으로 되어 있다.
- 처리시간 **T**는 `0.1s`, `0.312s`, `2s` 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 `s`로 끝난다.
- 예를 들어, 로그 문자열 `2016-09-15 03:10:33.020 0.011s`은 2016년 9월 15일 오전 3시 10분 **33.010초**부터 2016년 9월 15일 오전 3시 10분 **33.020초**까지 **0.011초** 동안 처리된 요청을 의미한다. **(처리시간은 시작시간과 끝시간을 포함)**
- 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 **0.001 ≦ T ≦ 3.000**이다.
- `lines` 배열은 응답완료시간 **S**를 기준으로 오름차순 정렬되어 있다. 

### 출력 형식

- `solution` 함수에서는 로그 데이터 `lines` 배열에 대해 **초당 최대 처리량**을 리턴한다.

### 입출력 예제

#### 예제1

- 입력: [
  2016-09-15 01:00:04.001 2.0s,
  2016-09-15 01:00:07.000 2s
  ]
- 출력: 1

#### 예제2

- 입력: [
  2016-09-15 01:00:04.002 2.0s,
  2016-09-15 01:00:07.000 2s
  ]
- 출력: 2
- 설명: 처리시간은 시작시간과 끝시간을 **포함**하므로
  첫 번째 로그는 `01:00:02.003 ~ 01:00:04.002`에서 2초 동안 처리되었으며,
  두 번째 로그는 `01:00:05.001 ~ 01:00:07.000`에서 2초 동안 처리된다.
  따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 `01:00:04.002 ~ 01:00:05.001` 1초 동안 최대 2개가 된다.

#### 예제3

- 입력: [
  2016-09-15 20:59:57.421 0.351s,
  2016-09-15 20:59:58.233 1.181s,
  2016-09-15 20:59:58.299 0.8s,
  2016-09-15 20:59:58.688 1.041s,
  2016-09-15 20:59:59.591 1.412s,
  2016-09-15 21:00:00.464 1.466s,
  2016-09-15 21:00:00.741 1.581s,
  2016-09-15 21:00:00.748 2.31s,
  2016-09-15 21:00:00.966 0.381s,
  2016-09-15 21:00:02.066 2.62s
  ]
- 출력: 7



### 풀이

입력값 형식을 보자마자 C++로는 답이 없음을 느껴서 파이썬을 사용했다.  예전처럼 C++ 원툴로 문제 풀었다가는 문자열 처리하는데 시간 다 갈 듯 하다. 

최소 시간 단위가 정해져 있지만, 0.001s 단위로 구간을 이동해서 전수조사했다가는 당연히 시간 초과가 나게 설정해 놨을거라 생각하여 다르게 구현하였다. 

lines 자체가 이미 끝나는 시간 순으로 정렬되어서 입력되므로, 끝나는 시간 순으로 정렬된 base와 시작 시간 순으로 정렬된 base_sorted 두 리스트를 이용하여 구간을 모두 조사한다. 입력값 가공을 포함한 구현 로직은 다음과 같다.

##### <입력값 처리>

1. 문자열을 공백 단위로 쪼갠 후,  시간/분/초만 따로 때서 일괄적으로 초로 변경한다.

2. (index, [시작 시간, 끝 시간])으로 데이터를 정리한다.

3. 시작시간으로 정렬한 리스트 base_sorted를 따로 구해서 정의한다.

   

##### <구현부>

1. timestamp + 1초 안에 **시작된 처리 요청**을 모두 count한다. 
2. count한 구간이 최대면 answer 갱신
3. 측정하지 않은 처리요청이 있다면 timestamp를 다음 요청이 끝나는 시간으로 갱신하고, count를 1 줄인다.



```python
def solution(lines):
    #log의 시간 문자열을 전부 초로 변환. 하루 동안의 로그만 측정하므로 년/월/일은 무시
    origin = list(map(lambda x: float((x.split()[1])[0:2]) * 3600 + float((x.split()[1])[3:5]) * 60 + float((x.split()[1])[6:]),lines))
    base = [(r, [0, origin[r]]) for r in range(0,len(origin))]
    for i in range(len(base)):
        
    #요청 처리 시작 시간을 base[i][1][0]에 계산해서 입력.
        base[i][1][0] = round(base[i][1][1] - float(lines[i].split()[2][0:-1]) + 0.001, 3)
        
	#시작시간 순서대로 정렬
    base_sorted = list(base)
    base_sorted.sort(key=lambda x: x[1][0])
    
    #계산에 필요한 변수 선언
    timestamp = base[0][1][1]
    index_front, index_back, answer, size = 0, 0, 0, 0
    
    #로직 구현부
    while True:
        for i in range(index_front, len(base)):
            if base_sorted[index_front][1][0] < timestamp + 1:
                index_front += 1
                size += 1
            else:
                break
        if answer < size:
            answer = size
        if index_front >= len(base):
            break
        index_back += 1
        timestamp = base[index_back][1][1]
        size -= 1

    return answer
```



